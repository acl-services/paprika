import { Meta } from "@storybook/addon-docs/blocks";
import tokens from "@paprika/tokens";
import Toast from "@paprika/toast";
import DataGrid, { renderColumnIndicator, renderColumnExpand } from "../src";
import fixtures from "./helpers/fixtures";
import { App as Marvel } from "./DataGrid.marvel.stories";
import { App as Stress } from "./DataGrid.stressing.stories";
import { App as Collapsible } from "./DataGrid.Collapse.stories";

<Meta title="DataGrid/Documentation" />

# DataGrid

Helps you in rendering vast amount of tabular data.

Main features:

- By design is a controlled component gives full flexibility to the consumer
- Virtualization provide by [react-windows](https://react-window.now.sh/)
- Sticky header and Sticky Columns _(right side)_
- Easy mapping cell values or custom cell render _(render function)_
- Voice-over **a11y**
- Support for keyboard navigation `‚Üë`, `‚Üì`, `‚Üí`, `‚Üê` **a11y**
- Easy Api for keyboard events `Enter`, `Space`, `Shift + Space` **a11y**
- Dynamic width and height for the cells [VariableSizeGrid](https://react-window.now.sh/#/examples/grid/variable-size)
- Load more and infinity scroll patterns include it

## Installation

There are two main way to install DataGrid:

`yarn add @paprika/data-grid`

or

`npm install @paprika/data-grid`

## Context

Galvanize has a very tight relationship with Tables, DataGrids and Data. Our ecosystem is
full with them. These tables present and filter the data in different ways, sometime even
with different style and interaction patterns.

With this DataGrid we are creating a standard for our Tables in our ecosystem and at the same time providing our developers with a component which is easy to use.

## How to use it?

### Basic example

There are two requirements for rendering a simple **DataGrid** provide a an array with objects and describe how you want to render those objects on the DataGrid, example:

```js
const data = [
  /* column */ /* colum */
  { myColum1: 1, myColum2: "hi" }, // row 1
  { myColum1: 2, myColum2: "hello" }, // row 2
  { myColum1: 3, myColum2: "hola" }, // row 3
];
```

Each object inside of the array will represent a row while the properties inside of each object represents a potential columns to be rendered.

After we have our raw data in place, we can continue to describe how do we want to render the component using the `DataGrid.ColumnDefinition` subcomponent.

```js
const data = [
  /* column */ /* colum */
  { myColum1: 1, myColum2: "hi" }, // row 1
  { myColum1: 2, myColum2: "hello" }, // row 2
  { myColum1: 3, myColum2: "hola" }, // row 3
];

<DataGrid data={data}>
  <DataGrid.ColumnDefinition header="Column 1" cell="myColum1" />
  <DataGrid.ColumnDefinition header="Column 2" cell="myColum2" />
</DataGrid>;
```

#### The Result

<DataGrid
  data={[{ myColum1: 1, myColum2: "hi" }, { myColum1: 2, myColum2: "hello" }, { myColum1: 3, myColum2: "hola" }]}
>
  <DataGrid.ColumnDefinition header="Column 1" cell="myColum1" />
  <DataGrid.ColumnDefinition header="Column 2" cell="myColum2" />
</DataGrid>

You can notice that we only need to tell to the DataGrid which property we want to rendered in the columns. If we would want to, we could render only one property (column)
in our DataGrid.

Also worth noting that you can have any kind of information store on your objects, the DataGrid doesn't care.

### Custom cell content

Let's get fancy now, imagine that your ux-designer has requested to add an icon. If it's a greet containing the word`"hi"`, we should display a üëã emoji next to the word.

So, let's start working!.

```js
const data = [
  /* column */ /* colum */
  { myColum1: 1, myColum2: "hi" }, // row 1
  { myColum1: 2, myColum2: "hello" }, // row 2
  { myColum1: 3, myColum2: "hola" }, // row 3
];

<DataGrid data={data}>
  <DataGrid.ColumnDefinition header="Column 1" cell="myColum1" />
  <DataGrid.ColumnDefinition
    header="Column 2"
    cell={({ row }) => (row.myColum2 === "hola" ? `üëã ${myColum2}` : myColum2)}
  />
</DataGrid>;
```

#### The Result

<DataGrid
  data={[{ myColum1: 1, myColum2: "hi" }, { myColum1: 2, myColum2: "hello" }, { myColum1: 3, myColum2: "hola" }]}
>
  <DataGrid.ColumnDefinition header="Column 1" cell="myColum1" />
  <DataGrid.ColumnDefinition
    header="Column 2"
    cell={({ row }) => (row.myColum2 === "hi" ? `üëã ${row.myColum2}` : row.myColum2)}
  />
</DataGrid>

<br />

<Toast hasCloseButton={false} kind="warning">
  Every time you use a function as a value of the cell prop. You need to include also a cellA11yText function.
</Toast>

### Accessibility **cellA11yText** and **headerA11yText**

Whenever you use a render function on the `cell` or `header` prop you have to add a `cellA11yText` and `headerA11yText` function to
help the voice over to speak out correctly the cell content, this function **most** return a string.

```js
<DataGrid>
  <DataGrid.ColumnDefinition
    {...otherProps}
    cell={({ row }) => <MyComponent {...row} />}
    cellA11yText={({ row }) => {
      // you can concatenate or build your own string to help voiceover
      return `${row.someStringValue}`;
    }}
    cell={({ row }) => <MyComponent {...row} />}
    headerA11yText={({ row }) => {
      // you can concatenate or build your own string to help voiceover
      return `${row.someStringValue}`;
    }}
  />
</DataGrid>
```

### Styling cells

So far easy, we have our `DataGrid` displaying all of the basic requirements, but we can do more.

Let's add some custom styling to our cells, in case if the greet includes the `letter o` we should render a blue background.

```js

const style = {
  background: `${row.myColum2.includes("o") ? tokens.color.blueLighten40	 : "transparent"}`
}

<DataGrid data={data}>
  <DataGrid.ColumnDefinition header="Column 1" cell="myColum1" />
  <DataGrid.ColumnDefinition header="Column 2"
    cell={
      ({row}) => (row.myColum2 === "hi") ? `üëã ${row.myColum2}` : row.myColum2
    }
    cellProps={({ row }) => ({ style })
  }
  />
</DataGrid>
```

#### The Result

<DataGrid
  data={[{ myColum1: 1, myColum2: "hi" }, { myColum1: 2, myColum2: "hello" }, { myColum1: 3, myColum2: "hola" }]}
>
  <DataGrid.ColumnDefinition header="Column 1" cell="myColum1" />
  <DataGrid.ColumnDefinition
    header="Column 2"
    cell={({ row }) => (row.myColum2 === "hi" ? `üëã ${row.myColum2}` : row.myColum2)}
    cellProps={({ row }) => ({
      style: {
        background: `${row.myColum2.includes("o") ? tokens.color.blueLighten40 : "transparent"}`,
      },
    })}
  />
</DataGrid>

<br />
<Toast kind="info" hasCloseButton={false}> Tip Because `cell` and `cellProps` are functions can be memorize in case of needing it.</Toast>

### Sticky headers

By default all our header are sticky and mandatory, so you will have this feature enable, without doing anything, enjoy it üòÑ.

### Sticky columns

Sticky columns are easy to enables the only requirement is to mark the columns you want
to be sticky with the prop `isSticky` on the `<ColumnDefinition />` component and list all your sticky columns before any other **no** sticky column to prevent issues with the keyboard arrows navigation.

```js
<DataGrid data={data} width={680}>
  <DataGrid.ColumnDefinition isSticky width={180} header="Name" cell="name" />
  <DataGrid.ColumnDefinition header="Countries" cell="country" />
  <DataGrid.ColumnDefinition header="Goals" cell="goals" />
  <DataGrid.ColumnDefinition header="link" cell="link" />
  <DataGrid.ColumnDefinition header="Status" cell="status" />
  <DataGrid.ColumnDefinition header="Status 2" cell="status" />
  <DataGrid.ColumnDefinition header="Description" cell="description" />
  <DataGrid.ColumnDefinition header="Status 3" cell="status" />
</DataGrid>
```

### The Result

<DataGrid data={fixtures(5)} width={680}>
  <DataGrid.ColumnDefinition width={180} isSticky header="Name" cell="name" />
  <DataGrid.ColumnDefinition header="Countries" cell="country" />
  <DataGrid.ColumnDefinition header="Goals" cell="goals" />
  <DataGrid.ColumnDefinition header="link" cell="link" />
  <DataGrid.ColumnDefinition header="Status" cell="status" />
  <DataGrid.ColumnDefinition header="Status 2" cell="status" />
  <DataGrid.ColumnDefinition header="Description" cell="description" />
  <DataGrid.ColumnDefinition header="Status 3" cell="status" />
</DataGrid>

### Custom columns

It's possible to create your own columns and encapsulated the logic inside of a function.

This serves as a way to encapsulated logic which can be reuse in different DataGrids.

Already the `DataGrid` exposes two of these kind of columns the `renderColumnIndicator` and `renderColumnExpand`. Example:

`import DataGrid, { renderColumnIndicator, renderColumnExpand } from "@paprika/data-grid";`

Example:

```js
<DataGrid data={data} width={680}>
  {renderColumnIndicator()}
  {renderColumnExpand()}
  <DataGrid.ColumnDefinition header="Name" cell="name" />
  <DataGrid.ColumnDefinition header="Countries" cell="country" />
  <DataGrid.ColumnDefinition header="Goals" cell="goals" />
  <DataGrid.ColumnDefinition header="Status" cell="status" />
  <DataGrid.ColumnDefinition header="Status 2" cell="status" />
  <DataGrid.ColumnDefinition header="Description" cell="description" />
  <DataGrid.ColumnDefinition header="Status 3" cell="status" />
</DataGrid>
```

### The Result

<DataGrid data={fixtures(2)} width={680}>
  {renderColumnIndicator()}
  {renderColumnExpand()}
  <DataGrid.ColumnDefinition header="Name" cell="name" />
  <DataGrid.ColumnDefinition header="Countries" cell="country" />
  <DataGrid.ColumnDefinition header="Goals" cell="goals" />
  <DataGrid.ColumnDefinition header="Status" cell="status" />
  <DataGrid.ColumnDefinition header="Status 2" cell="status" />
  <DataGrid.ColumnDefinition header="Description" cell="description" />
  <DataGrid.ColumnDefinition header="Status 3" cell="status" />
</DataGrid>

### How to create custom columns

Custom columns are easy to create, you only need to return a `<ColumnDefinition />` tailored to your needs, let's create a custom column that show an alert each time is clicked.

```js
function renderAlertColumn() {
  return (
    <DataGrid.ColumnDefinition
      onClick={({ row, rowIndex }) => {
        alert(row.name);
      }}
      header="alert"
      cell={() => "click me"}
    />
  );
}

<DataGrid data={data} width={680}>
  {renderAlertColumn()}
  <DataGrid.ColumnDefinition header="Name" cell="name" />
  <DataGrid.ColumnDefinition header="Countries" cell="country" />
  <DataGrid.ColumnDefinition header="Goals" cell="goals" />
  <DataGrid.ColumnDefinition header="Status" cell="status" />
  <DataGrid.ColumnDefinition header="Status 2" cell="status" />
  <DataGrid.ColumnDefinition header="Description" cell="description" />
  <DataGrid.ColumnDefinition header="Status 3" cell="status" />
</DataGrid>;
```

<Toast kind="info" hasCloseButton={false}>
  Tip: You can use of React.useCallback() in case you need to memonize your custom column
</Toast>

---

### The Result

<DataGrid data={fixtures(2)} width={680}>
  {React.useCallback(
    (() => {
      return (
        <DataGrid.ColumnDefinition
          onClick={({ row, rowIndex }) => {
            alert(row.name);
          }}
          header="alert"
          cell={() => "click me"}
        />
      );
    })(),
    []
  )}
  <DataGrid.ColumnDefinition header="Name" cell="name" />
  <DataGrid.ColumnDefinition header="Countries" cell="country" />
  <DataGrid.ColumnDefinition header="Goals" cell="goals" />
  <DataGrid.ColumnDefinition header="Status" cell="status" />
</DataGrid>

## Load more

There are two patterns to load more data shipped with this component, the traditional load more button and the infinity scrolling, we will discussed the former in the next section and the `Load more` in this one.

As part of the DataGrid component you can make use of the `<DataGrid.Basement>` subcomponent which is in charge of hiding or showing its content depending if the scrollbar reaching the bottom or not.

```js
<DataGrid data={data}>
  <DataGrid.ColumnDefinition header="..." cell="..." />
  <DataGrid.ColumnDefinition header="..." cell="..." />
  <DataGrid.Basement>{/* your content or load more button goes here */}</DataGrid.Basement>
</DataGrid>
```

## Elaborated example with Marvel API

<Marvel />

### Infinity Scroll

To make use of the `Infinity Scroll` pattern you have to provide a callback function and the rows offset before reaching the bottom which will be use as a trigger to call the function.

```js
<DataGrid data={data}>
  <DataGrid.ColumnDefinition header="..." cell="..." />
  <DataGrid.ColumnDefinition header="..." cell="..." />
  <DataGrid.InfinityScroll rowsOffset={80} onReached={() => {
    /* you can request more data */
  })} />
</DataGrid>
```

#### Elaborated example

Uses your `‚Üë`, `‚Üì` keys or scroll to the bottom of the table to load more rows automatically.

<Stress overrideWidth={680} numberOfColumns={15} rowsOffset={120} />

### More Example

#### Collapsible DataGrid

This is an example of what can be achieved from consumer side.

<Collapsible />

## FAQ

**Should I use the DataGrid for all my Tables problems?**

The DataGrid is a flexible component which might be sufficient for a lot of scenarios
where showing Tabular Data is required.

Saying that, there are some limitation with the DataGrid. The DataGrid is not meant to
be a Spreadsheet, neither to react dynamically to different size of content like a regular
HTML Table would do, so for this kind of scenarios is better to find alternatives solutions.

In doubt asked your fellow ux-developer or reach to us on our Galvaize's slack #paprika channel.

**Performance issues within my DataGrid, how do I fix them?**

While the DataGrid has been designed to render a lot of information, its performance can be affected by multiple reason like:

- Number of rows and cells rendered on the DataGrid in full screen.
- Number of screens connected to your computer.
- Scrolling by a mouse wheel instead a magic pad.
- The browsers some are better than others
- The UI and what you are rendering.

To mitigated some of these problems you could use `React.Memo` or `memonize` your components. Also you could
use [workerize](https://github.com/developit/workerize) to process complex logic, without blocking the main thread.

**Sticky headers and columns on my DataGris are not sync while scrolling.**

We are aware of this issue unfortunately, React-Window doesn't provide a build-in solution for sticky columns, we expect to mitigated this problems in incoming releases

**How can I remove the `padding / margin` from the Cells?**

The `<ColumnDefinition />` has a `cellProps` props that you can use to pass specific styles to your cell, as well any other attribute that you might require like classes or `data` attributes.

<br />

<Toast kind="warning" hasCloseButton={false}>
  Theoretically you could also pass down a _styled-component_ `css` prop using the `cellProps` but don't do it, let's
  not exploit our internal implementation details for styling our components üôè
</Toast>

**How many rows and columns can I render on the DataGrid**

This is a complex question to answer.

_Short answer:_ I don't know.
_Long answer:_ It will depends on different factors as hardware, number or row and columns on the viewport, what kind of content is on the cells, etc.

But the good news is that most of the cases you will not have to worry about this, most regular uses cases the DataGrid will perform without problems.

For those specific edge case where you require to load hundred of thousand or Million rows/columns, the DataGrid will not be the only one responsible to provide a great user experience the way how the data is stream and provided will play a bigger role.

[react-window](https://react-window.now.sh/) as ou virtualize
